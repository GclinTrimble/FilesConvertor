<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-DEM Viewer with Row Mapping Test</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body { margin: 0; font-family: 'Inter', sans-serif; overflow: hidden; }
        #mainContainer { display: flex; height: calc(100vh - 4rem - 3.5rem); }
        #demListPanel { width: 300px; background-color: #374151; padding: 10px; overflow-y: auto; border-right: 1px solid #4b5563; }
        #demListPanel h3 { font-size: 1.1rem; font-semibold; margin-bottom: 10px; color: white; }
        #demListPanel ul { list-style: none; padding: 0; }
        #demListPanel li { background-color: #4b5563; margin-bottom: 8px; padding: 8px; border-radius: 4px; }
        #demListPanel .dem-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;}
        #demListPanel li label { color: white; font-size: 0.875rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 5px; flex-grow: 1;}
        #demListPanel li input[type="checkbox"] { accent-color: #3b82f6; width: 1rem; height: 1rem; flex-shrink: 0; margin-right: 8px; }
        #demListPanel .dem-item-coords { font-size: 0.75rem; color: #d1d5db; padding-left: 2px; margin-bottom: 4px; }
        #demListPanel .export-btn-small {
            background-color: #4f46e5; color: white; font-size: 0.7rem; padding: 2px 6px;
            border-radius: 3px; border: none; cursor: pointer; margin-left: auto;
        }
        #demListPanel .export-btn-small:hover { background-color: #4338ca; }


        #canvasContainer { flex-grow: 1; height: 100%; position: relative; }
        canvas { display: block; cursor: crosshair; }
        .loader {
            border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%;
            width: 60px; height: 60px; animation: spin 1s linear infinite;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 10; display: none;
        }
        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
        #aiDescriptionPanel {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background-color: rgba(42, 50, 62, 0.9); color: white; padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 20; max-width: 90%; width: 500px;
            display: none;
        }
        #aiDescriptionPanelContent { max-height: 200px; overflow-y: auto; font-size: 0.9rem; line-height: 1.4; }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="flex flex-col h-screen">
        <header class="bg-gray-800 p-3 shadow-md h-16">
            <h1 class="text-xl font-semibold text-center">Multi-DEM Viewer</h1>
        </header>

        <div class="bg-gray-700 p-3 shadow-md flex flex-wrap items-center justify-center gap-2 md:gap-3 h-[3.5rem]">
            <div>
                <label for="fileInput" class="text-sm font-medium mr-2">Load DEM(s):</label>
                <input type="file" id="fileInput" accept=".asc" multiple class="text-sm text-gray-300 file:mr-2 file:py-1 file:px-2 file:rounded-md file:border file:border-gray-500 file:text-sm file:font-semibold file:bg-gray-600 file:text-gray-200 hover:file:bg-gray-500 rounded-md">
            </div>
            <button id="centerViewBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-1 px-3 rounded-md text-sm disabled:opacity-50" disabled>Center View</button>
            <div>
                <label for="materialType" class="text-sm font-medium mr-1">Shading:</label>
                <select id="materialType" class="bg-gray-600 border border-gray-500 text-white text-sm rounded-md p-1 focus:ring-blue-500 focus:border-blue-500 disabled:opacity-50" disabled>
                    <option value="default">Default</option>
                    <option value="colorElevation">Color Elev.</option>
                    <option value="grayElevation">Gray Elev.</option>
                </select>
            </div>
            <button id="getAIDescriptionBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-1 px-3 rounded-md text-sm disabled:opacity-50" disabled>âœ¨ Describe</button>
            <button id="exportUnifiedBtn" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-1 px-3 rounded-md text-sm disabled:opacity-50" disabled>Export Visible (GLB)</button>
        </div>

        <div id="mainContainer">
            <div id="demListPanel">
                <h3>Loaded DEMs</h3>
                <ul id="demList"></ul>
            </div>
            <main class="flex-grow relative bg-gray-800" id="canvasOuterContainer">
                <div id="canvasContainer">
                    <div id="loader" class="loader"></div>
                </div>
                <div id="statusMessage" class="absolute bottom-2 left-2 bg-gray-900 bg-opacity-75 text-xs p-2 rounded-md">
                    Please load DEM file(s). Click on terrain for coordinates.
                </div>
                <div id="aiDescriptionPanel">
                    <button id="closeAIDescriptionBtn" class="absolute top-2 right-3 text-gray-300 hover:text-white text-xl font-bold">&times;</button>
                    <h3 class="text-lg font-semibold mb-2">AI Generated Terrain Description</h3>
                    <div id="aiDescriptionPanelContent">Loading description...</div>
                </div>
            </main>
        </div>
    </div>

    <script type="importmap"> { 
        "imports": { 
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", 
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "three/addons/exporters/GLTFExporter.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/exporters/GLTFExporter.js"
        } 
    } </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

        let scene, camera, renderer, controls;
        let directionalLight, ambientLight;
        let loadedDEMs = []; 
        let fileIdCounter = 0;
        const MAX_POINTS_PER_CHUNK = 10_000_000;
        let raycaster;
        const pointer = new THREE.Vector2();
        let lastMouseIntersectionPoint = null; 
        let firstDemAbsoluteOrigin = { x: null, y: null }; 


        const ui = {
            canvasContainer: document.getElementById('canvasContainer'),
            fileInput: document.getElementById('fileInput'),
            centerViewBtn: document.getElementById('centerViewBtn'),
            materialTypeSelect: document.getElementById('materialType'),
            statusMessage: document.getElementById('statusMessage'),
            loader: document.getElementById('loader'),
            getAIDescriptionBtn: document.getElementById('getAIDescriptionBtn'),
            aiDescriptionPanel: document.getElementById('aiDescriptionPanel'),
            aiDescriptionPanelContent: document.getElementById('aiDescriptionPanelContent'),
            closeAIDescriptionBtn: document.getElementById('closeAIDescriptionBtn'),
            demListUl: document.getElementById('demList'),
            exportUnifiedBtn: document.getElementById('exportUnifiedBtn')
        };

        const elevationVertexShader = `varying float vElevation; varying vec3 vNormal; void main() { vElevation = position.z; vNormal = normalize(normalMatrix * normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
        const colorElevationFragmentShader = `varying float vElevation; varying vec3 vNormal; uniform float minElevation; uniform float maxElevation; uniform vec3 uDirectionalLightDirection; uniform vec3 uDirectionalLightColor; uniform vec3 uAmbientLightColor; vec3 colorRamp(float t) { vec3 c1=vec3(0.0,0.0,1.0); vec3 c2=vec3(0.0,1.0,0.0); vec3 c3=vec3(1.0,1.0,0.0); vec3 c4=vec3(1.0,0.0,0.0); if(t<0.0) t=0.0; if(t>1.0) t=1.0; if(t<0.33) return mix(c1,c2,t/0.33); if(t<0.66) return mix(c2,c3,(t-0.33)/0.33); return mix(c3,c4,(t-0.66)/0.34); } void main() { vec3 baseColor; if(maxElevation==minElevation){ baseColor=vec3(0.5,0.5,0.5); } else { baseColor=colorRamp((vElevation-minElevation)/(maxElevation-minElevation)); } vec3 norm=normalize(vNormal); float dotNL=max(dot(norm,normalize(uDirectionalLightDirection)),0.0); vec3 diffuse=uDirectionalLightColor*dotNL; vec3 finalColor=baseColor*(uAmbientLightColor+diffuse); gl_FragColor=vec4(finalColor,1.0); }`;
        const grayElevationFragmentShader = `varying float vElevation; varying vec3 vNormal; uniform float minElevation; uniform float maxElevation; uniform vec3 uDirectionalLightDirection; uniform vec3 uDirectionalLightColor; uniform vec3 uAmbientLightColor; void main() { vec3 baseColor; if(maxElevation==minElevation){ baseColor=vec3(0.5,0.5,0.5); } else { float nE=(vElevation-minElevation)/(maxElevation-minElevation); nE=clamp(nE,0.0,1.0); baseColor=vec3(nE,nE,nE); } vec3 norm=normalize(vNormal); float dotNL=max(dot(norm,normalize(uDirectionalLightDirection)),0.0); vec3 diffuse=uDirectionalLightColor*dotNL; vec3 finalColor=baseColor*(uAmbientLightColor+diffuse); gl_FragColor=vec4(finalColor,1.0); }`;
        let defaultMaterial;
        const lightWorldDirection = new THREE.Vector3();
        const viewSpaceLightDirection = new THREE.Vector3();

        function initThreeJS() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x2d3748);
            camera = new THREE.PerspectiveCamera(75, ui.canvasContainer.clientWidth / ui.canvasContainer.clientHeight, 0.1, 100000);
            camera.position.set(0, -200, 200); camera.up.set(0, 0, 1); 
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(ui.canvasContainer.clientWidth, ui.canvasContainer.clientHeight);
            ui.canvasContainer.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            controls.minPolarAngle = 0; controls.maxPolarAngle = Math.PI * 0.495; 
            ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 50, 50); scene.add(directionalLight); 
            defaultMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, flatShading: false });
            raycaster = new THREE.Raycaster();
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            renderer.domElement.addEventListener('mousemove', onCanvasMouseMove, false);
            renderer.domElement.addEventListener('mousedown', onCanvasMouseDown, false);
            renderer.domElement.addEventListener('wheel', onCanvasWheel, { passive: false });
            animate();
            window.addEventListener('resize', onWindowResize, false);
            setTimeout(onWindowResize, 0);
        }

        function onWindowResize() {
            if (!renderer || !camera || !ui.canvasContainer) return;
            const newWidth = ui.canvasContainer.clientWidth; const newHeight = ui.canvasContainer.clientHeight;
            if (newWidth > 0 && newHeight > 0) {
                camera.aspect = newWidth / newHeight; camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            }
        }

        function animate() {
            requestAnimationFrame(animate); controls.update(); 
            if (directionalLight && camera) {
                directionalLight.getWorldDirection(lightWorldDirection); lightWorldDirection.negate();
                viewSpaceLightDirection.copy(lightWorldDirection).transformDirection(camera.matrixWorldInverse).normalize();
                loadedDEMs.forEach(dem => {
                    if (dem.isVisible && dem.mesh && dem.mesh.material instanceof THREE.ShaderMaterial) {
                        if (dem.mesh.material.uniforms.uDirectionalLightDirection) {
                            dem.mesh.material.uniforms.uDirectionalLightDirection.value.copy(viewSpaceLightDirection);
                        }
                    }
                });
            }
            renderer.render(scene, camera);
        }

        function updatePointer(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onCanvasMouseMove(event) {
            updatePointer(event); raycaster.setFromCamera(pointer, camera);
            const visibleMeshes = loadedDEMs.filter(dem => dem.isVisible).map(dem => dem.mesh);
            if (visibleMeshes.length > 0) {
                const intersects = raycaster.intersectObjects(visibleMeshes);
                if (intersects.length > 0) {
                    if (!lastMouseIntersectionPoint) lastMouseIntersectionPoint = new THREE.Vector3();
                    lastMouseIntersectionPoint.copy(intersects[0].point);
                } 
            }
        }
        
        function onCanvasMouseDown(event) {
            if (lastMouseIntersectionPoint && controls) {
                if ( (event.button === controls.mouseButtons.LEFT && controls.enableRotate) ||
                     (event.button === controls.mouseButtons.MIDDLE && controls.enablePan) ||
                     (event.button === controls.mouseButtons.RIGHT && controls.enablePan) ) {
                    controls.target.copy(lastMouseIntersectionPoint);
                }
            }
        }

        function onCanvasWheel(event) {
            if (lastMouseIntersectionPoint && controls && controls.enableZoom) {
                controls.target.copy(lastMouseIntersectionPoint);
            }
        }

        function onCanvasClick(event) {
            updatePointer(event); raycaster.setFromCamera(pointer, camera);
            const visibleMeshes = loadedDEMs.filter(dem => dem.isVisible).map(dem => dem.mesh);
            if (visibleMeshes.length === 0) return;
            const intersects = raycaster.intersectObjects(visibleMeshes);
            if (intersects.length > 0) {
                const intersect = intersects[0]; const point = intersect.point;
                const demName = loadedDEMs.find(d => d.mesh === intersect.object)?.name || "Unknown DEM";
                ui.statusMessage.textContent = `Clicked on ${demName}: X: ${point.x.toFixed(2)}, Y: ${point.y.toFixed(2)}, Z (Elevation): ${point.z.toFixed(2)}`;
            } else {
                ui.statusMessage.textContent = "No terrain clicked. Click on terrain for coordinates.";
            }
        }
        
        function _parseFullASCIIGridData(fileContent, fileNameForLogging = "Unknown File") {
            try {
                const lines = fileContent.split(/\r?\n/); const header = {}; let dataStartIndex = 0;
                const headerKeys = ["ncols", "nrows", "xllcorner", "yllcorner", "cellsize", "nodata_value"];
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim(); if (!line) continue;
                    const parts = line.split(/\s+/);
                    if (parts.length >= 2 && headerKeys.includes(parts[0].toLowerCase())) header[parts[0].toLowerCase()] = parseFloat(parts[1]);
                    else if (Object.keys(header).length >= headerKeys.length-1 && parts.every(p => !isNaN(parseFloat(p)))) { dataStartIndex = i; break; }
                    if (i > 10 && Object.keys(header).length < 4) throw new Error("Invalid DEM header format.");
                }
                const requiredKeys = ["ncols", "nrows", "cellsize"];
                for (const key of requiredKeys) if (typeof header[key] !== 'number' || isNaN(header[key])) throw new Error(`Missing/invalid: '${key}'.`);
                const geoKeys = ["xllcorner", "yllcorner", "nodata_value"];
                const defaultGeoValues = { "xllcorner": 0, "yllcorner": 0, "nodata_value": -9999 };
                for (const key of geoKeys) if (typeof header[key] !== 'number' || isNaN(header[key])) header[key] = defaultGeoValues[key];
                const ncols = Math.floor(header.ncols); const nrows = Math.floor(header.nrows);
                const nodata_value = header.nodata_value; const elevationData = [];
                let minElev = Infinity; let maxElev = -Infinity; let validDataPoints = 0;
                for (let i = 0; i < nrows; i++) {
                    const line = lines[dataStartIndex + i];
                    if (!line) { elevationData.push(new Array(ncols).fill(nodata_value)); continue; }
                    const values = line.trim().split(/\s+/).map(parseFloat);
                    const rowToAdd = new Array(ncols).fill(nodata_value);
                    for(let k=0; k < Math.min(values.length, ncols); k++) rowToAdd[k] = values[k];
                    elevationData.push(rowToAdd);
                    for (const val of rowToAdd) if (val !== nodata_value && !isNaN(val)) { if (val < minElev) minElev = val; if (val > maxElev) maxElev = val; validDataPoints++; }
                }
                if (validDataPoints === 0) { minElev = 0; maxElev = 0; }
                if (minElev === Infinity) minElev = nodata_value !== -Infinity ? nodata_value : 0;
                if (maxElev === -Infinity) maxElev = nodata_value !== Infinity ? nodata_value : 0;
                return { header, data: elevationData, minElev, maxElev };
            } catch (error) { console.error(`Full Parse Error (${fileNameForLogging}):`, error); ui.statusMessage.textContent = `Parse Error for ${fileNameForLogging}: ${error.message}`; return null; }
        }

        function parseAndSplitASCIIGridController(fileContent, originalFileName) {
            ui.statusMessage.textContent = `Processing ${originalFileName}...`;
            const fullParsedData = _parseFullASCIIGridData(fileContent, originalFileName);
            if (!fullParsedData) return [];
            const { header: originalHeader, data: originalElevationData } = fullParsedData;
            const totalPoints = originalHeader.ncols * originalHeader.nrows;
            if (totalPoints <= MAX_POINTS_PER_CHUNK) {
                return [{ name: originalFileName, parsedData: fullParsedData }];
            }
            console.log(`DEM ${originalFileName} is too large (${totalPoints} points). Splitting...`);
            ui.statusMessage.textContent = `Splitting ${originalFileName} (large file)...`;
            const resultsArray = []; let numChunksX = 1; let numChunksY = 1;
            while (true) {
                const currentChunkCols = Math.ceil(originalHeader.ncols / numChunksX);
                const currentChunkRows = Math.ceil(originalHeader.nrows / numChunksY);
                if (currentChunkCols * currentChunkRows <= MAX_POINTS_PER_CHUNK) break;
                if (numChunksX * originalHeader.nrows > numChunksY * originalHeader.ncols) numChunksY++; else numChunksX++;
                if (numChunksX > originalHeader.ncols && numChunksY > originalHeader.nrows) { return [{ name: originalFileName, parsedData: fullParsedData }]; }
            }
            console.log(`Splitting ${originalFileName} into ${numChunksX}x${numChunksY} chunks.`);
            ui.statusMessage.textContent = `Splitting ${originalFileName} into ${numChunksX * numChunksY} chunks...`;
            for (let cy = 0; cy < numChunksY; cy++) {
                for (let cx = 0; cx < numChunksX; cx++) {
                    const chunkName = `${originalFileName}_part${cy}_${cx}`;
                    const startRowOrig = Math.floor(cy * originalHeader.nrows / numChunksY);
                    const endRowOrig = Math.floor((cy + 1) * originalHeader.nrows / numChunksY);
                    const chunkNRows = endRowOrig - startRowOrig;
                    const startColOrig = Math.floor(cx * originalHeader.ncols / numChunksX);
                    const endColOrig = Math.floor((cx + 1) * originalHeader.ncols / numChunksX);
                    const chunkNCols = endColOrig - startColOrig;
                    if (chunkNCols <= 0 || chunkNRows <= 0) continue;
                    const chunkHeader = { ...originalHeader };
                    chunkHeader.ncols = chunkNCols; chunkHeader.nrows = chunkNRows;
                    chunkHeader.xllcorner = originalHeader.xllcorner + (startColOrig * originalHeader.cellsize);
                    // Using USER-PROVIDED YLLCORNER FIX for split chunks
                    chunkHeader.yllcorner = originalHeader.yllcorner + ((originalHeader.nrows - endRowOrig) * originalHeader.cellsize); 
                    console.log(`[${chunkName}] YLLCorner Calc (USER): origYLL=${originalHeader.yllcorner}, origNRows=${originalHeader.nrows}, endRowOrig=${endRowOrig}, cellSize=${originalHeader.cellsize}, finalChunkYLL=${chunkHeader.yllcorner}`);
                    const chunkElevationData = []; let chunkMinElev = Infinity; let chunkMaxElev = -Infinity; let chunkValidPoints = 0;
                    for (let r = 0; r < chunkNRows; r++) {
                        const originalRowIndex = startRowOrig + r;
                        if (originalRowIndex < 0 || originalRowIndex >= originalHeader.nrows) continue;
                        const originalRowData = originalElevationData[originalRowIndex];
                        const newRow = originalRowData.slice(startColOrig, endColOrig);
                        chunkElevationData.push(newRow);
                        for (const val of newRow) if (val !== chunkHeader.nodata_value && !isNaN(val)) { if (val < chunkMinElev) chunkMinElev = val; if (val > chunkMaxElev) chunkMaxElev = val; chunkValidPoints++; }
                    }
                    if (chunkValidPoints === 0) { chunkMinElev = 0; chunkMaxElev = 0; }
                    if (chunkMinElev === Infinity) chunkMinElev = chunkHeader.nodata_value !== -Infinity ? chunkHeader.nodata_value : 0;
                    if (chunkMaxElev === -Infinity) chunkMaxElev = chunkHeader.nodata_value !== Infinity ? chunkHeader.nodata_value : 0;
                    resultsArray.push({ name: chunkName, parsedData: { header: chunkHeader, data: chunkElevationData, minElev: chunkMinElev, maxElev: chunkMaxElev } });
                }
            }
            return resultsArray;
        }

        function createAndAddTerrain(fileName, parsedData) {
            const { header, data, minElev, maxElev } = parsedData;
            const ncols = Math.floor(header.ncols); const nrows = Math.floor(header.nrows);
            const cellsize = header.cellsize; const nodata_value = header.nodata_value;
            const planeWidthForGeom = (ncols - 1) * cellsize; 
            const planeHeightForGeom = (nrows - 1) * cellsize;
            
            if (firstDemAbsoluteOrigin.x === null) { // Set origin based on the very first piece of DEM loaded
                firstDemAbsoluteOrigin.x = header.xllcorner;
                firstDemAbsoluteOrigin.y = header.yllcorner;
                console.log(`[${fileName}] SETTING First DEM Absolute Origin: X=${firstDemAbsoluteOrigin.x}, Y=${firstDemAbsoluteOrigin.y}`);
            }

            // Calculate position relative to the first DEM's origin
            const relativeX = header.xllcorner - firstDemAbsoluteOrigin.x;
            const relativeY = header.yllcorner - firstDemAbsoluteOrigin.y;
            
            console.log(`[${fileName}] Creating Terrain Mesh. Abs xll=${header.xllcorner}, yll=${header.yllcorner}. Rel X=${relativeX}, Rel Y=${relativeY} for mesh center.`);

            const geometry = new THREE.PlaneGeometry(planeWidthForGeom, planeHeightForGeom, Math.max(1, ncols - 1), Math.max(1, nrows - 1));
            const positions = geometry.attributes.position;
            
            console.log(`[${fileName}] Applying DEM row mapping: demRow = j (was (nrows - 1) - j). This assumes DEM data rows are bottom-to-top.`);
            for (let j = 0; j < nrows; j++) { // j is PlaneGeometry row (bottom-up)
                for (let i = 0; i < ncols; i++) { // i is PlaneGeometry col (left-right)
                    const vertexIndex = i + j * ncols;
                    // MODIFIED ROW MAPPING:
                    const demRow = j; // Assumes DEM data is ordered bottom-up (row 0 is southernmost)
                    // const demRow = (nrows - 1) - j; // Standard: Assumes DEM data is top-down (row 0 is northernmost)
                    const demCol = i; 

                    let elevation = (data[demRow] && data[demRow][demCol] !== undefined) ? data[demRow][demCol] : nodata_value;
                    if (elevation === undefined || elevation === null || isNaN(elevation) || elevation === nodata_value) elevation = minElev; 
                    if (positions.array.length > vertexIndex * 3 + 2) positions.setZ(vertexIndex, elevation);
                }
            }
            geometry.computeVertexNormals();
            const currentFileId = fileIdCounter++;
            const demEntry = {
                id: `dem-${currentFileId}`, name: fileName,
                mesh: new THREE.Mesh(geometry, defaultMaterial), 
                demData: parsedData, // Store original parsed data with its own absolute header
                materials: { default: defaultMaterial }, 
                isVisible: true, fileId: currentFileId
            };
            
            // Position the mesh's CENTER using the calculated relative coordinates
            demEntry.mesh.position.set(relativeX, relativeY, 0); 
            console.log(`[${fileName}] Mesh center (relative to first DEM) set to X: ${demEntry.mesh.position.x}, Y: ${demEntry.mesh.position.y}`);

            scene.add(demEntry.mesh);
            loadedDEMs.push(demEntry);
            addDemToPanel(demEntry); 
            updateDemMaterial(demEntry, ui.materialTypeSelect.value); 
            ui.centerViewBtn.disabled = false; ui.materialTypeSelect.disabled = false; ui.getAIDescriptionBtn.disabled = false; ui.exportUnifiedBtn.disabled = false;
        }
        
        function addDemToPanel(demEntry) {
            const li = document.createElement('li'); li.id = `item-${demEntry.id}`;
            const headerDiv = document.createElement('div'); headerDiv.className = 'dem-item-header';
            const label = document.createElement('label'); 
            label.setAttribute('for', `vis-${demEntry.id}`); label.textContent = demEntry.name; label.title = demEntry.name;
            const checkbox = document.createElement('input'); 
            checkbox.type = 'checkbox'; checkbox.id = `vis-${demEntry.id}`; checkbox.checked = demEntry.isVisible;
            checkbox.addEventListener('change', (e) => { 
                demEntry.isVisible = e.target.checked; 
                demEntry.mesh.visible = demEntry.isVisible; 
                // DO NOT recenter view on visibility toggle
            });
            const exportButton = document.createElement('button');
            exportButton.textContent = 'GLB';
            exportButton.className = 'export-btn-small';
            exportButton.title = 'Export this DEM as GLB';
            exportButton.onclick = () => exportIndividualDemGLB(demEntry);

            headerDiv.appendChild(checkbox);
            headerDiv.appendChild(label);
            headerDiv.appendChild(exportButton);
            li.appendChild(headerDiv);
            const coordsDiv = document.createElement('div');
            coordsDiv.className = 'dem-item-coords';
            // Displaying the original absolute xllcorner/yllcorner from the header of this specific DEM/chunk
            coordsDiv.textContent = `Origin (abs): X: ${demEntry.demData.header.xllcorner.toFixed(2)}, Y: ${demEntry.demData.header.yllcorner.toFixed(2)}`;
            li.appendChild(coordsDiv);
            ui.demListUl.appendChild(li);
        }

        function updateDemMaterial(demEntry, materialType) {
            const { minElev, maxElev } = demEntry.demData;
            const effectiveAmbientColor = new THREE.Color(ambientLight.color).multiplyScalar(ambientLight.intensity);
            const effectiveDirectionalColor = new THREE.Color(directionalLight.color).multiplyScalar(directionalLight.intensity);
            if (materialType === 'colorElevation') {
                if (!demEntry.materials.color) {
                    demEntry.materials.color = new THREE.ShaderMaterial({ vertexShader: elevationVertexShader, fragmentShader: colorElevationFragmentShader, uniforms: { minElevation: { value: minElev }, maxElevation: { value: maxElev }, uDirectionalLightDirection: { value: new THREE.Vector3(0.5,0.5,1).normalize() }, uDirectionalLightColor: { value: effectiveDirectionalColor }, uAmbientLightColor: { value: effectiveAmbientColor } } });
                } else { demEntry.materials.color.uniforms.minElevation.value = minElev; demEntry.materials.color.uniforms.maxElevation.value = maxElev; }
                demEntry.mesh.material = demEntry.materials.color;
            } else if (materialType === 'grayElevation') {
                if (!demEntry.materials.gray) {
                    demEntry.materials.gray = new THREE.ShaderMaterial({ vertexShader: elevationVertexShader, fragmentShader: grayElevationFragmentShader, uniforms: { minElevation: { value: minElev }, maxElevation: { value: maxElev }, uDirectionalLightDirection: { value: new THREE.Vector3(0.5,0.5,1).normalize() }, uDirectionalLightColor: { value: effectiveDirectionalColor }, uAmbientLightColor: { value: effectiveAmbientColor } } });
                } else { demEntry.materials.gray.uniforms.minElevation.value = minElev; demEntry.materials.gray.uniforms.maxElevation.value = maxElev; }
                demEntry.mesh.material = demEntry.materials.gray;
            } else { demEntry.mesh.material = demEntry.materials.default; }
        }
        
        function updateAllDemMaterials() { loadedDEMs.forEach(dem => { updateDemMaterial(dem, ui.materialTypeSelect.value); }); }

        function centerView() {
            const visibleMeshes = loadedDEMs.filter(dem => dem.isVisible).map(dem => dem.mesh);
            const targetPointForSync = new THREE.Vector3(); 
            if (visibleMeshes.length === 0) { 
                camera.position.set(0, -200, 200); controls.target.set(0,0,0); targetPointForSync.set(0,0,0);
            } else {
                const overallBoundingBox = new THREE.Box3();
                visibleMeshes.forEach((mesh, index) => {
                    mesh.updateMatrixWorld(); const meshBoundingBox = new THREE.Box3().setFromObject(mesh, true); 
                    if (index === 0) overallBoundingBox.copy(meshBoundingBox); else overallBoundingBox.union(meshBoundingBox);
                });
                if (overallBoundingBox.isEmpty()) {
                     camera.position.set(0, -200, 200); controls.target.set(0,0,0); targetPointForSync.set(0,0,0);
                } else {
                    const center = overallBoundingBox.getCenter(new THREE.Vector3()); 
                    const size = overallBoundingBox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    if (maxDim === 0 || !isFinite(maxDim)) { 
                        camera.position.set(0, -200, 200); controls.target.set(0,0,0); targetPointForSync.set(0,0,0);
                    } else {
                        const fov = camera.fov * (Math.PI / 180);
                        const largerXYDim = Math.max(size.x, size.y);
                        let cameraDistance = Math.abs(largerXYDim / 2 / Math.tan(fov / 2));
                        cameraDistance = Math.max(cameraDistance, size.z); cameraDistance *= 1.5; 
                        camera.position.set(center.x, center.y - cameraDistance * 0.707, center.z + cameraDistance * 0.707); 
                        controls.target.copy(center); targetPointForSync.copy(center);
                    }
                }
            }
            if (!lastMouseIntersectionPoint) lastMouseIntersectionPoint = new THREE.Vector3();
            lastMouseIntersectionPoint.copy(targetPointForSync);
        }
        
        async function getTerrainDescription() {
            let targetDem = null; for (let i=loadedDEMs.length-1; i>=0; i--) if (loadedDEMs[i].isVisible) { targetDem=loadedDEMs[i]; break; }
            if (!targetDem) { ui.aiDescriptionPanelContent.textContent="No visible DEM to describe."; ui.aiDescriptionPanel.style.display='block'; return; }
            ui.aiDescriptionPanelContent.innerHTML = `<div class="flex items-center justify-center"><div class="loader-small border-t-purple-500" style="width:20px; height:20px; border-width:3px; animation: spin 1s linear infinite;"></div><span class="ml-2">Generating for ${targetDem.name}...</span></div>`;
            ui.aiDescriptionPanel.style.display='block'; ui.getAIDescriptionBtn.disabled=true;
            const { header, minElev, maxElev } = targetDem.demData; 
            const prompt = `Describe this terrain: ${targetDem.name}, Columns: ${header.ncols}, Rows: ${header.nrows}, Cell Size: ${header.cellsize}, Min Elev: ${minElev.toFixed(2)}, Max Elev: ${maxElev.toFixed(2)}. Brief, geographical.`;
            try {
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }]; const payload = { contents: chatHistory }; const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorData = await response.json(); throw new Error(`API Error: ${errorData.error?.message || response.status}`); }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) ui.aiDescriptionPanelContent.textContent = result.candidates[0].content.parts[0].text;
                else throw new Error("No valid content from API.");
            } catch (error) { ui.aiDescriptionPanelContent.textContent = `Error: ${error.message}`; }
            finally { ui.getAIDescriptionBtn.disabled = false; }
        }

        function triggerGLBDownload(glbData, fileName) {
            const blob = new Blob([glbData], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link); 
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            ui.statusMessage.textContent = `Exported ${fileName}`;
        }

        function exportIndividualDemGLB(demEntry) {
            if (!demEntry || !demEntry.mesh) {
                ui.statusMessage.textContent = "Error: DEM entry or mesh not found for export.";
                return;
            }
            ui.statusMessage.textContent = `Exporting ${demEntry.name} as GLB...`;
            const exporter = new GLTFExporter();
            exporter.parse(
                demEntry.mesh,
                (glb) => triggerGLBDownload(glb, `${demEntry.name.replace('.asc', '')}.glb`),
                (error) => { 
                    console.error('Error exporting individual GLB:', error); 
                    ui.statusMessage.textContent = `Error exporting ${demEntry.name}. See console.`;
                },
                { binary: true }
            );
        }

        function exportUnifiedVisibleDemsGLB() {
            const visibleDems = loadedDEMs.filter(dem => dem.isVisible);
            if (visibleDems.length === 0) {
                ui.statusMessage.textContent = "No visible DEMs to export.";
                return;
            }
            ui.statusMessage.textContent = "Exporting unified GLB of visible DEMs...";
            const group = new THREE.Group();
            visibleDems.forEach(demEntry => {
                const clone = demEntry.mesh.clone(); 
                group.add(clone); 
            });

            const exporter = new GLTFExporter();
            exporter.parse(
                group,
                (glb) => triggerGLBDownload(glb, 'unified_dems.glb'),
                (error) => {
                     console.error('Error exporting unified GLB:', error);
                     ui.statusMessage.textContent = "Error exporting unified GLB. See console.";
                },
                { binary: true }
            );
        }


        ui.fileInput.addEventListener('change', async (event) => {
            const files = event.target.files; if (!files || files.length === 0) return;
            if (loadedDEMs.length === 0) { firstDemAbsoluteOrigin.x = null; firstDemAbsoluteOrigin.y = null; }
            ui.loader.style.display = 'block'; ui.statusMessage.textContent = `Loading ${files.length} file(s)...`;
            ui.aiDescriptionPanel.style.display = 'none'; 
            let filesProcessedSuccessfully = 0;
            for (const file of files) {
                if (!file.name.toLowerCase().endsWith('.asc')) {
                    ui.statusMessage.textContent = `Skipping non .asc file: ${file.name}`; console.warn(`Skipping non .asc file: ${file.name}`); continue;
                }
                try {
                    const fileContent = await file.text();
                    const demChunksData = parseAndSplitASCIIGridController(fileContent, file.name); 
                    if (demChunksData && demChunksData.length > 0) {
                        for (const chunk of demChunksData) { createAndAddTerrain(chunk.name, chunk.parsedData); }
                        filesProcessedSuccessfully++;
                    } else { ui.statusMessage.textContent = `Failed to process ${file.name}. Check console.`; }
                } catch (error) {
                    console.error(`Error processing file ${file.name}:`, error);
                    ui.statusMessage.textContent = `Error processing ${file.name}: ${error.message}`;
                }
            }
            ui.loader.style.display = 'none';
            if (loadedDEMs.length > 0) {
                 ui.statusMessage.textContent = `${loadedDEMs.length} DEM(s)/chunk(s) loaded. Click on terrain for coordinates.`; centerView(); 
            } else if (files.length > 0 && filesProcessedSuccessfully === 0) {
                 ui.statusMessage.textContent = "No valid DEMs were loaded. Check files or console.";
            } else {
                 ui.statusMessage.textContent = "Please load DEM file(s). Click on terrain for coordinates."; 
            }
            ui.fileInput.value = ''; 
        });

        ui.centerViewBtn.addEventListener('click', centerView);
        ui.materialTypeSelect.addEventListener('change', updateAllDemMaterials);
        ui.getAIDescriptionBtn.addEventListener('click', getTerrainDescription);
        ui.closeAIDescriptionBtn.addEventListener('click', () => { ui.aiDescriptionPanel.style.display = 'none'; });
        ui.exportUnifiedBtn.addEventListener('click', exportUnifiedVisibleDemsGLB);


        initThreeJS();
    </script>
</body>
</html>
